#include <windows.h>
#include <syelog.h>

#include "Store.h"

static
HI_PROCESS_CONTEXT *pProcessList = NULL;

static
CRITICAL_SECTION gStoreCriticalSection;

#define LOCKED_DO(x)	do {						\
	EnterCriticalSection(&gStoreCriticalSection);	\
	x;												\
	LeaveCriticalSection(&gStoreCriticalSection);	\
} while(0)

HI_PROCESS_CONTEXT *StoreGetProcessContext(HANDLE hProcess)
{
	HI_PROCESS_CONTEXT *pc = pProcessList;

	while(pc) {
		if(pc->hProcess == hProcess)
			break;

		pc = pc->pNext;
	}

	if(!pc) {
		pc = (HI_PROCESS_CONTEXT*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(HI_PROCESS_CONTEXT));
		if(!pc)
			return pc;

		pc->hProcess = hProcess;
		pc->MemoryAllocationList = NULL;
		pc->pPrev = NULL;

		LOCKED_DO({
			pc->pNext = pProcessList;
			(pProcessList && (pProcessList->pPrev = pc));
			pProcessList = pc;
		});
	}

	return pc;
}

HI_MEMORY_CONTEXT *StoreFindMemoryContext(HI_PROCESS_CONTEXT *pProcess, LPVOID lpAddr)
{
	DWORD dw;
	HI_MEMORY_CONTEXT *mc;

	if(!pProcessList)
		return NULL;

	mc = pProcessList->MemoryAllocationList;
	dw = (DWORD) lpAddr;

	while(mc) {
		if((dw >= mc->dwBaseAddress) && (dw < (mc->dwBaseAddress + mc->dwSize)))
			break;

		mc = mc->pNext;
	}

	return mc;
}

static
HI_MEMORY_CONTEXT *StoreGetMemoryContext(HI_PROCESS_CONTEXT *pProcessCtx, LPVOID lpAddr, SIZE_T dwSize, DWORD flType, DWORD flProtect)
{
	HI_MEMORY_CONTEXT *mc = StoreFindMemoryContext(pProcessCtx, lpAddr);

	if(!mc) {
		mc = (HI_MEMORY_CONTEXT*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(HI_MEMORY_CONTEXT));
		if(!mc)
			return mc;

		mc->lpStore = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwSize + 1);
		if(!mc->lpStore) {
			HeapFree(GetProcessHeap(), 0, mc);
			return NULL;
		}

		mc->dwBaseAddress = (DWORD) lpAddr;
		mc->dwSize = dwSize;
		mc->flAllocationType = flType;
		mc->flProtect = flProtect;
		mc->pPrev = NULL;
		
		LOCKED_DO({
			mc->pNext = pProcessCtx->MemoryAllocationList;
			(pProcessCtx->MemoryAllocationList && (pProcessCtx->MemoryAllocationList->pPrev = mc));
			pProcessCtx->MemoryAllocationList = mc;
		});
	}

	return mc;
}

BOOL StoreHandleAllocation(HANDLE hProcess, LPVOID lpAddr, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect)
{
	HI_PROCESS_CONTEXT *pCtx;
	HI_MEMORY_CONTEXT *mCtx;

	pCtx = StoreGetProcessContext(hProcess);
	if(!pCtx) {
		Syelog(SYELOG_SEVERITY_NOTICE, "Store: Failed to get process context for allocation");
		return FALSE;
	}

	mCtx = StoreGetMemoryContext(pCtx, lpAddr, dwSize, flAllocationType, flProtect);
	if(!mCtx) {
		Syelog(SYELOG_SEVERITY_NOTICE, "Store: Failed to get memory context for allocation");
		return FALSE;
	}

	Syelog(SYELOG_SEVERITY_NOTICE, "Store: New allocation created at 0x%08x (pCtx=0x%08x mCtx=0x%08x)", 
		mCtx->dwBaseAddress, (DWORD) pCtx, (DWORD) mCtx);

	return TRUE;
}

BOOL StoreHandleMemoryWrite(HANDLE hProcess, LPVOID lpTargetAddr, LPVOID lpBuffer, DWORD dwSize)
{
	HI_PROCESS_CONTEXT *pCtx;
	HI_MEMORY_CONTEXT *mCtx;

	DWORD dwOffset;

	pCtx = StoreGetProcessContext(hProcess);
	if(!pCtx) {
		Syelog(SYELOG_SEVERITY_NOTICE, "Store: Failed to get process context for memory write");
		return FALSE;
	}

	mCtx = StoreFindMemoryContext(pCtx, lpTargetAddr);
	if(!mCtx) {
		Syelog(SYELOG_SEVERITY_NOTICE, "Store: Failed to get memory context for memory write");
		return FALSE;	// WPM without Allocation??
	}

	dwOffset = ((DWORD) lpTargetAddr) - mCtx->dwBaseAddress;

	if((dwOffset + dwSize) > mCtx->dwSize) {
		Syelog(SYELOG_SEVERITY_NOTICE, "Store: Overflow condition hit during Memory Write, auto adjusting..");
		dwSize -= (dwOffset + dwSize) - mCtx->dwSize;
	}

	Syelog(SYELOG_SEVERITY_NOTICE, "Store: Storing %d bytes at 0x%08x", dwSize, ((DWORD) mCtx->lpStore) + dwOffset);

	CopyMemory((LPVOID) (((DWORD) mCtx->lpStore) + dwOffset), lpBuffer, dwSize);
	return TRUE;
}

BOOL StoreIsMemoryWritten(HANDLE hProcess, LPVOID lpAddr)
{
	HI_PROCESS_CONTEXT *pCtx;

	pCtx = StoreGetProcessContext(hProcess);
	if(!pCtx)
		return FALSE;

	if(StoreFindMemoryContext(pCtx, lpAddr))
		return TRUE;
	else
		return FALSE;
}

BOOL StoreDumpMemoryContext(HI_PROCESS_CONTEXT *pCtx, HI_MEMORY_CONTEXT *mCtx)
{
	return FALSE;
}

BOOL StoreDumpProcessContext(HI_PROCESS_CONTEXT *pCtx)
{
	return FALSE;
}

VOID StoreInit()
{
	InitializeCriticalSection(&gStoreCriticalSection);
}

VOID StoreExit()
{

}