#include <windows.h>
#include <syelog.h>
#include <detours.h>
#include <psapi.h>

#include "HookHandlers.h"
#include "DetourFunctions.h"
#include "Store.h"
#include "Config.h"
#include "Dumper.h"

#pragma comment(lib, "psapi")

// Our Hooked Functions
static
	HANDLE (WINAPI *Real_OpenProcess)(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId) = OpenProcess;
static
	LPVOID (WINAPI *Real_VirtualAllocEx)(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect) = VirtualAllocEx;
static
	BOOL (WINAPI *Real_WriteProcessMemory)(HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten) = WriteProcessMemory;
static
	HANDLE (WINAPI *Real_CreateRemoteThread)(HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId) = CreateRemoteThread;

static
HANDLE WINAPI HookHandleOpenProcess(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId)
{
	Syelog(SYELOG_SEVERITY_NOTICE, "HookHandler: OpenProcess(pid=%d)", dwProcessId);
	return Real_OpenProcess(dwDesiredAccess, bInheritHandle, dwProcessId);
}

static
LPVOID WINAPI HookHandleVirtualAllocEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect)
{
	LPVOID	lpAddr;

	Syelog(SYELOG_SEVERITY_NOTICE, "HookHandler: VirtualAllocEx(HANDLE=0x%08x dwSize=%d)", hProcess, dwSize);

	lpAddr = Real_VirtualAllocEx(hProcess, lpAddress, dwSize, flAllocationType, flProtect);
	if(!lpAddr)
		return lpAddr;

	StoreHandleAllocation(hProcess, lpAddr, dwSize, flAllocationType, flProtect);
	return lpAddr;
}

static
BOOL WINAPI HookHandleWriteProcessMemory(HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten)
{
	Syelog(SYELOG_SEVERITY_NOTICE, "HookHandler: WriteProcessMemory(HANDLE=0x%08x Target=0x%08x Source=0x%08x Size=%d",
		hProcess, (DWORD) lpBaseAddress, (DWORD) lpBuffer, nSize);

	__try {
		StoreHandleMemoryWrite(hProcess, lpBaseAddress, (LPVOID) lpBuffer, nSize);
	}
	__except(EXCEPTION_EXECUTE_HANDLER) {
		Syelog(SYELOG_SEVERITY_NOTICE, "HookHandler: Error occurred while handling memory write");
	}

	return Real_WriteProcessMemory(hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesWritten);
}

static
HANDLE WINAPI HookHandleCreateRemoteThread(HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId)
{
	CHAR	szPath[MAX_PATH + 1];
	HANDLE	hThread = NULL;

	Syelog(SYELOG_SEVERITY_NOTICE, "HookHandler: CreateRemoteThread(HANDLE=0x%08x ThreadProc=0x%08x",
		hProcess, (DWORD) lpStartAddress);

	if(StoreIsMemoryWritten(hProcess, (LPVOID) lpStartAddress)) {
		GetModuleFileNameExA(hProcess, NULL, szPath, MAX_PATH);
		
		Syelog(SYELOG_SEVERITY_NOTICE, "** Attempted execution of injected code. Target: %s CurrentThreadId: %d StartAddr: 0x%08x",
			szPath, GetCurrentThreadId(), (DWORD) lpStartAddress);

		DumperDumpMemory(hProcess, (LPVOID) lpStartAddress, "CRT");
	}

	if(MONITOR_CONFIG->uAllowRemoteThread)
		hThread = Real_CreateRemoteThread(hProcess, lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpThreadId);
	else
		Syelog(SYELOG_SEVERITY_NOTICE, "** CreateRemoteThread(..) denied due to configuration");
	
	return hThread;
}

VOID HookHandlersInit()
{
	StoreInit();
}

VOID HookHandlersExit()
{
	StoreExit();
}

VOID HookInit()
{
	HookHandlersInit();

	DetourTransactionBegin();
	DetourUpdateThread(GetCurrentThread());

	DetourAttach(&(LPVOID&) Real_OpenProcess, (LPVOID) HookHandleOpenProcess);
	DetourAttach(&(LPVOID&) Real_VirtualAllocEx, (LPVOID) HookHandleVirtualAllocEx);
	DetourAttach(&(LPVOID&) Real_WriteProcessMemory, (LPVOID) HookHandleWriteProcessMemory);
	DetourAttach(&(LPVOID&) Real_CreateRemoteThread, (LPVOID) HookHandleCreateRemoteThread);

	if(DetourTransactionCommit() != NO_ERROR)
		Syelog(SYELOG_SEVERITY_NOTICE, "Error occurred while initializing Hooks (GLE: %d)", GetLastError());
	else
		Syelog(SYELOG_SEVERITY_NOTICE, "Hooks Initialized");
}

VOID HookExit()
{
	HookHandlersExit();

	DetourTransactionBegin();
	DetourUpdateThread(GetCurrentThread());

	DetourDetach(&(LPVOID&) Real_OpenProcess, (LPVOID) HookHandleOpenProcess);
	DetourDetach(&(LPVOID&) Real_VirtualAllocEx, (LPVOID) HookHandleVirtualAllocEx);
	DetourDetach(&(LPVOID&) Real_WriteProcessMemory, (LPVOID) HookHandleWriteProcessMemory);
	DetourDetach(&(LPVOID&) Real_CreateRemoteThread, (LPVOID) HookHandleCreateRemoteThread);

	DetourTransactionCommit();
}