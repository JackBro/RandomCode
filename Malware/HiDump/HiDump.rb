$:.unshift("C:\\Lib\\metasm")

require 'metasm'
require 'optparse'
require 'tempfile'

MONITOR_DLL_PATH = File.join(File.dirname(__FILE__), 'bin', 'monitor.dll')

::Metasm::WinAPI.new_api_c <<EOS, 'kernel32'

	DWORD WINAPI WaitForSingleObject(
		HANDLE hHandle,
		DWORD dwMilliseconds
	);

EOS

$LOADLIBRARY_SHELLCODE = 
	# Win32 PEB based API Resolver
	"\xe8\x56\x00\x00\x00\x53\x55\x56\x57\x8b\x6c\x24\x18\x8b\x45\x3c" +
	"\x8b\x54\x05\x78\x01\xea\x8b\x4a\x18\x8b\x5a\x20\x01\xeb\xe3\x32" +
	"\x49\x8b\x34\x8b\x01\xee\x31\xff\xfc\x31\xc0\xac\x38\xe0\x74\x07" +
	"\xc1\xcf\x0d\x01\xc7\xeb\xf2\x3b\x7c\x24\x14\x75\xe1\x8b\x5a\x24" +
	"\x01\xeb\x66\x8b\x0c\x4b\x8b\x5a\x1c\x01\xeb\x8b\x04\x8b\x01\xe8" +
	"\xeb\x02\x31\xc0\x5f\x5e\x5d\x5b\xc2\x08\x00\x31\xc9\x64\x8b\x71" +
	"\x30\x8b\x76\x0c\x8b\x76\x1c\x8b\x5e\x08\x8b\x7e\x20\x8b\x36\x66" +
	"\x39\x4f\x18\x75\xf2\x5e\x53\x68\x8e\x4e\x0e\xec\xff\xd6\x89\xc7" +
	"\x57\x56\x53\x89\xe5" +
	
	# %define LoadLibraryA     [ebp + 8]
	# %define LGetProcAddress  [ebp + 4]
	# %define KERNEL32 BASE    [ebp + 0]

	Metasm::Shellcode.assemble(Metasm::Ia32.new, %Q{
		
		jmp _end
		_start:
		
		pop ecx		; DLL Path in ECX
		
		; LoadLibraryA(DLL)
		push ecx
		call [ebp + 8]
		
		call _getNtdll
		db 'ntdll.dll', 0x00
		
	_getNtdll:
		call [ebp + 8]		; LoadLibraryA('ntdll.dll')
		
		push eax
		push 0xff7f061a		; RtlExitUserThread
		call [ebp + 4]
		
		xor ebx, ebx
		push ebx
		call eax			; RtlExitUserThread(0)
		
		int 3
		
	_end:
		call _start
		; Path (ASCII) for DLL goes here

}).encode_string()

class MonitorConfig
	SECTION_NAME = ".config"
	
	attr_accessor :szWorkingDir	# 260
	attr_accessor :uAllowRemoteThread
	
	def initialize(opts)
		self.szWorkingDir = opts[:working_directory].gsub("/", "\\")
		self.uAllowRemoteThread = opts[:disable_remote_thread] ? 0 : 1
	end
	
	def pack
		self.szWorkingDir = pad(self.szWorkingDir, 260)
		
		(
			self.szWorkingDir + 
			[self.uAllowRemoteThread].pack('C')
		)
	end
	
	private
	def pad(d, s, v = "\x00")
		d + (v * (s - d.size))
	end
end

def _vmsg(msg)
	if $options[:verbose]
		if $options[:verbose_file]
			$options[:verbose_file].puts("[*] #{msg}")
		else
			$stdout.puts("[*] #{msg}")
		end
	end
end

def _msg(msg)
	$stdout.puts("[+] #{msg}")
end

def _emsg(msg)
	$stderr.puts("[-] #{msg}")
end

def hid_get_configured_monitor()
	##File.binread(MONITOR_DLL_PATH)
	
	_msg("Preparing monitor dll with config")
	
	pe_orig = ::Metasm::PE.decode_file(MONITOR_DLL_PATH)
	
	pe = pe_orig.mini_copy
	pe.mz.encoded = pe_orig.encoded[0, pe_orig.coff_offset - 4]
	pe.mz.encoded.export = pe_orig.encoded[0, 512].export.dup
	pe.header.time = pe_orig.header.time
	
	section = ::Metasm::PE::Section.new
	section.name = ::MonitorConfig::SECTION_NAME
	section.characteristics = %w[MEM_READ]
	section.encoded = ::Metasm::EncodedData.new(::MonitorConfig.new($options).pack())
	
	pe.sections << section
	pe.invalidate_header
	
	pe.cpu	# reference to load CPU
	
	return pe.encode_string()
end

def hid_get_prepared_monitor_path()
	m_path = Tempfile.new("hid-monitor").path + '.dll'
	
	fd = File.open(m_path, "wb") do |fd|
		fd.write(hid_get_configured_monitor())
		fd.close
	end
	
	m_path = m_path.gsub("/", "\\")
	_vmsg("Configured monitor dll path: #{m_path}")
	
	return m_path
end

# Inject Monitor and Run Target
def run_hidump()
	startupinfo = ::Metasm::WinAPI.alloc_c_struct('STARTUPINFOA', :cb => :size)
	processinfo = ::Metasm::WinAPI.alloc_c_struct('PROCESS_INFORMATION')
	
	flags = ::Metasm::WinAPI::CREATE_SUSPENDED
	
	_msg("Starting Target with CREATE_SUSPENDED flag (#{$options[:target]})")
	
	bRet = ::Metasm::WinAPI.createprocessa(nil, $options[:target], nil, nil, 0, flags, nil, nil, startupinfo, processinfo)
	raise "CreateProcessA: #{::Metasm::WinAPI.last_error_msg}" unless bRet
	
	_msg("Process created with pid: #{processinfo.dwprocessid}")
	_msg("Injecting monitor dll")
	
	process = ::Metasm::WinOS::Process.new(processinfo.dwprocessid, processinfo.hprocess)
	thread  = ::Metasm::WinOS::Thread.new(processinfo.dwthreadid, processinfo.hthread, process)
	
	::Metasm::WinOS.inject_run_shellcode(process, $LOADLIBRARY_SHELLCODE + hid_get_prepared_monitor_path() + "\x00")
	
	_msg("Waiting")
	sleep 2
	
	_msg("Resuming execution of target")
	::Metasm::WinAPI.resumethread(thread.handle)
	
	_msg("Waiting for target to finish execution")
	::Metasm::WinAPI.waitforsingleobject(process.handle, ::Metasm::WinAPI::INFINITE)
	
	_msg("Finished")
end

def validate_options!
	if $options[:target].nil?
		_emsg("Target executable path not specified")
		exit(1)
	elsif $options[:working_directory].nil?
		_emsg("Working directory path not specified")
		exit(1)
	end
end

if __FILE__ == $0
	exit if defined?(Ocra)
	
	$options = {}
	
	opp = OptionParser.new do |opts|
		opts.banner = "Usage: HiDump.rb [options]"
		
		opts.on("-t", "--target [TARGET]", "Target executable to run") do |t|
			$options[:target] = t.to_s
		end
		
		opts.on("-v", "--verbose", "Enable verbose messages") do
			$options[:verbose] = true
		end
		
		opts.on("-d", "--working-directory [DIR]", "Working directory for Monitor (default: curr dir)") do |d|
			$options[:working_directory] = File.expand_path(d.to_s)
		end
		
		opts.on("-x", "--no-remote-thread", "Do not allow CreateRemoteThread(..)") do
			$options[:disable_remote_thread] = true
		end
		
		opts.on("--syelogd", "Start Syelogd for Monitor debugging") do
			exec(File.join(File.dirname(__FILE__), "bin", "syelogd.exe"))
			exit(0)
		end
		
		opts.on("-h") do
			puts opp
			exit
		end
	end
	
	if ARGV.empty?
		puts opp
		exit(0)
	else
		opp.parse!
	end
	
	validate_options!
	Dir.mkdir($options[:working_directory]) unless File.exists? $options[:working_directory]
	run_hidump()
end